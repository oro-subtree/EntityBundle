## Automatic creation of REST API for dictionaries ##

Dictionary entities are responsible for storing a predefined set of values of a certain type and their translations. They values within a dictionary can have a priority or some other data.
Nevertheless, there is an automatic tool that creates a REST API resource for viewing dictionary values, which is accessible by the following URL:

`/api/rest/{version}/{dictionary_plural_alias}.{_format}`. For example `/api/rest/latest/casestatuses.json`.

All generated REST API resources for dictionary values are processed by a single [DictionaryController](./../../Controller/Api/Rest/DictionaryController.php).

The plural aliases for the dictionary entities are generated by the [EntityAliasResolver](./../../ORM/EntityAliasResolver.php). Please refer to the entity alias [document](entity_aliases.md) for more information.

**Supported dictionary types**

REST API resources are created automatically for the following types of dictionaries:
- Non-translatable dictionary
- Translatable dictionary (implements `Gedmo\Translatable\Entity\MappedSuperclass\AbstractTranslation`)
- Personal translatable dictionary (implements `Gedmo\Translatable\Entity\MappedSuperclass\AbstractPersonalTranslation`)
- Enum (Option set)


**Creating REST API for a custom dictionary type**

If you have a custom dictionary type and you want to have its entities added to the REST API,
all you need to do is to create a dictionary value list provider that will implement the [DictionaryValueListProviderInterface](./../../Provider/DictionaryValueListProviderInterface.php) interface:

```php
use Doctrine\Common\Persistence\ManagerRegistry;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\Mapping\ClassMetadata;

use Oro\Bundle\EntityBundle\EntityConfig\GroupingScope;
use Oro\Bundle\EntityConfigBundle\Config\ConfigManager;

class DictionaryValueListProvider implements DictionaryValueListProviderInterface
{
    /** @var ConfigManager */
    protected $configManager;

    /** @var ManagerRegistry */
    protected $doctrine;

    /**
     * @param ConfigManager   $configManager
     * @param ManagerRegistry $doctrine
     */
    public function __construct(
        ConfigManager $configManager,
        ManagerRegistry $doctrine
    ) {
        $this->configManager = $configManager;
        $this->doctrine      = $doctrine;
    }

    /**
     * {@inheritdoc}
     */
    public function supports($className)
    {
        $groupingConfigProvider = $this->configManager->getProvider('grouping');
        if (!$groupingConfigProvider->hasConfig($className)) {
            return false;
        }

        $groups = $groupingConfigProvider->getConfig($className)->get('groups');

        return !empty($groups) && in_array(GroupingScope::GROUP_DICTIONARY, $groups, true);
    }

    /**
     * {@inheritdoc}
     */
    public function getValueListQueryBuilder($className)
    {
        /** @var EntityManager $em */
        $em = $this->doctrine->getManagerForClass($className);
        $qb = $em->getRepository($className)->createQueryBuilder('e');

        return $qb;
    }

    /**
     * {@inheritdoc}
     */
    public function getSerializationConfig($className)
    {
        /** @var EntityManager $em */
        $em                   = $this->doctrine->getManagerForClass($className);
        $metadata             = $em->getClassMetadata($className);
        $extendConfigProvider = $this->configManager->getProvider('extend');

        $fields = [];
        foreach ($metadata->getFieldNames() as $fieldName) {
            $extendFieldConfig = $extendConfigProvider->getConfig($className, $fieldName);
            if ($extendFieldConfig->is('is_extend')) {
                // skip extended fields
                continue;
            }

            $fields[$fieldName] = null;
        }

        return [
            'exclusion_policy' => 'all',
            'hints'            => ['HINT_TRANSLATABLE'],
            'fields'           => $fields
        ];
    }

    /**
     * {@inheritdoc}
     */
    public function getSupportedEntityClasses()
    {
        $result = [];

        $groupingConfigProvider = $this->configManager->getProvider('grouping');
        foreach ($groupingConfigProvider->getConfigs(null, true) as $config) {
            $groups = $config->get('groups');
            if (!empty($groups) && in_array(GroupingScope::GROUP_DICTIONARY, $groups, true)) {
                $result[] = $config->getId()->getClassName();
            }
        }

        return $result;
    }
}
```

And register your provider service in the DI container using the `oro_entity.dictionary_value_list_provider` tag:

```yml
    oro_entity.dictionary_value_list_provider.default:
        class: %oro_entity.dictionary_value_list_provider.default.class%
        public: false
        arguments:
            - @oro_entity_config.config_manager
            - @doctrine
        tags:
            - { name: oro_entity.dictionary_value_list_provider, priority: -100 }
```

Please, note that you can specify the priority for the dictionary value list provider. The bigger the priority number is, the earlier the provider will be executed.
If there are more than one dictionary value list providers that support the same type of dictionary, only the one with the greater priority will be executed. The priority value is optional and defaults to 0.


**Troubleshooting**

In case if the REST API resource for your dictionary is not available, do the following:

- Make sure that `getSupportedEntityClasses()` method in the corresponding dictionary value provider returns your dictionary entity class
- Find the plural alias of your dictionary entity using `php app/console oro:entity-alias:debug` CLI command
- Check if this alias is present in the routing list with the help of `php app/console oro:entity-alias:debug` CLI command.
The found route name should start with the `oro_api_get_dictionary_values_` prefix, e.g.: `oro_api_get_dictionary_values_auto_790    GET    ANY    ANY  /api/rest/{version}/casestatuses.{_format}`
